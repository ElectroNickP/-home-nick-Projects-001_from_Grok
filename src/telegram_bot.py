import asyncio
import logging
import os
import re
import time

import openai
from aiogram import Bot, Dispatcher, types
from aiogram.client.bot import DefaultBotProperties
from aiogram.filters import Command
from aiogram.types import FSInputFile
from aiogram.utils.token import validate_token

from config_manager import CONVERSATIONS, CONVERSATIONS_LOCK, OPENAI_LOCK

logger = logging.getLogger(__name__)


def validate_telegram_token(token):
    """–í–∞–ª–∏–¥–∞—Ü–∏—è Telegram —Ç–æ–∫–µ–Ω–∞"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç —Ç–æ–∫–µ–Ω–∞ (–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ 123456789:ABCdefGHIjklMNOpqrsTUVwxyz)
        if not re.match(r"^\d+:[A-Za-z0-9_-]{35}$", token):
            logger.error(f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–æ–∫–µ–Ω–∞: {token}")
            return False, "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç–æ–∫–µ–Ω–∞"

        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é –≤–∞–ª–∏–¥–∞—Ü–∏—é aiogram
        validate_token(token)
        logger.info(f"‚úÖ –¢–æ–∫–µ–Ω –≤–∞–ª–∏–¥–µ–Ω: {token[:10]}...")
        return True, "–¢–æ–∫–µ–Ω –≤–∞–ª–∏–¥–µ–Ω"

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —Ç–æ–∫–µ–Ω–∞: {e}")
        return False, str(e)


# Configuration for group context analysis
GROUP_CONTEXT_MESSAGES_LIMIT = 15  # Number of recent messages to analyze in groups

# Store recent group messages for context analysis
GROUP_MESSAGES_CACHE = {}  # {chat_id: [message_data, ...]}


def get_user_info(message):
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ/–≥—Ä—É–ø–ø–µ –∏–∑ —Å–æ–æ–±—â–µ–Ω–∏—è Telegram."""
    user_info = {}
    
    if message.chat.type == "private":
        # –õ–∏—á–Ω—ã–π —á–∞—Ç - –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
        user = message.from_user
        if user:
            user_info = {
                "type": "user",
                "id": user.id,
                "username": user.username,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "display_name": None
            }
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–µ –∏–º—è
            if user.username:
                user_info["display_name"] = f"@{user.username}"
            elif user.first_name:
                full_name = user.first_name
                if user.last_name:
                    full_name += f" {user.last_name}"
                user_info["display_name"] = full_name
            else:
                user_info["display_name"] = f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user.id}"
    else:
        # –ì—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç - –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≥—Ä—É–ø–ø–µ
        chat = message.chat
        user_info = {
            "type": "group",
            "id": chat.id,
            "title": chat.title,
            "username": chat.username,
            "display_name": chat.title or f"–ì—Ä—É–ø–ø–∞ {chat.id}"
        }
    
    return user_info


def save_transcription_dialog(conversation_key, user_message, bot_response, user_info=None):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∏–∞–ª–æ–≥ –≤ —Ä–µ–∂–∏–º–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ."""
    import time
    
    current_time = int(time.time())
    
    with CONVERSATIONS_LOCK:
        if conversation_key not in CONVERSATIONS:
            CONVERSATIONS[conversation_key] = {
                "thread_id": None, 
                "messages": [],
                "user_info": user_info or {}
            }
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ, –µ—Å–ª–∏ –æ–Ω–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∞
        if user_info and "user_info" in CONVERSATIONS[conversation_key]:
            CONVERSATIONS[conversation_key]["user_info"].update(user_info)
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        CONVERSATIONS[conversation_key]["messages"].append({
            "role": "user",
            "content": user_message,
            "timestamp": current_time
        })
        
        # –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –±–æ—Ç–∞ (—Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—é –∏–ª–∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ)
        CONVERSATIONS[conversation_key]["messages"].append({
            "role": "assistant", 
            "content": bot_response,
            "timestamp": current_time + 1
        })
        
        logger.info(f"üíæ –î–∏–∞–ª–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ —Ä–µ–∂–∏–º–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä–∞: {conversation_key}")


async def transcribe_audio(file_path):
    """–¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∏—Ä—É–µ—Ç –∞—É–¥–∏–æ—Ñ–∞–π–ª —Å –ø–æ–º–æ—â—å—é OpenAI Whisper."""
    try:
        logger.info(f"üéß –ù–∞—á–∏–Ω–∞—é —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—é —Ñ–∞–π–ª–∞: {file_path}")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
        if not os.path.exists(file_path):
            logger.error(f"‚ùå –§–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω: {file_path}")
            return None

        file_size = os.path.getsize(file_path)
        logger.info(f"üìä –†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏: {file_size} –±–∞–π—Ç")

        if file_size == 0:
            logger.error(f"‚ùå –§–∞–π–ª –¥–ª—è —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –ø—É—Å—Ç–æ–π: {file_path}")
            return None

        logger.info("üì° –û—Ç–ø—Ä–∞–≤–ª—è—é —Ñ–∞–π–ª –≤ OpenAI Whisper API...")
        with open(file_path, "rb") as audio_file:
            # –î–æ–±–∞–≤–ª—è–µ–º timeout –¥–ª—è Whisper API (30 —Å–µ–∫—É–Ω–¥)
            transcript = await asyncio.wait_for(
                asyncio.to_thread(
                    openai.audio.transcriptions.create, model="whisper-1", file=audio_file
                ),
                timeout=30.0
            )

        result_text = transcript.text
        logger.info(f"üéØ Whisper API –æ—Ç–≤–µ—Ç–∏–ª: '{result_text}'")
        return result_text

    except asyncio.TimeoutError:
        logger.error("‚è∞ Whisper API –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –∑–∞ 30 —Å–µ–∫—É–Ω–¥ - –ø—Ä–µ–≤—ã—à–µ–Ω timeout")
        return None
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –∞—É–¥–∏–æ: {e}")
        return None


async def text_to_speech(text, config, voice_model="tts-1", voice="alloy"):
    """–ü—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ç–µ–∫—Å—Ç –≤ —Ä–µ—á—å —Å –ø–æ–º–æ—â—å—é OpenAI TTS API."""
    try:
        logger.info(f"üé§ –ù–∞—á–∏–Ω–∞—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –≥–æ–ª–æ—Å–∞ –¥–ª—è —Ç–µ–∫—Å—Ç–∞: '{text[:50]}...'")

        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É —Ç–µ–∫—Å—Ç–∞ (OpenAI TTS –∏–º–µ–µ—Ç –ª–∏–º–∏—Ç –≤ 4096 —Å–∏–º–≤–æ–ª–æ–≤)
        if len(text) > 4000:
            text = text[:4000] + "..."
            logger.warning("‚ö†Ô∏è –¢–µ–∫—Å—Ç –æ–±—Ä–µ–∑–∞–Ω –¥–æ 4000 —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è TTS")

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
        import uuid

        audio_filename = f"tts_{uuid.uuid4().hex[:8]}.mp3"

        logger.info("üì° –û—Ç–ø—Ä–∞–≤–ª—è—é —Ç–µ–∫—Å—Ç –≤ OpenAI TTS API...")
        with OPENAI_LOCK:
            client = openai.OpenAI(api_key=config["openai_api_key"])
            # –î–æ–±–∞–≤–ª—è–µ–º timeout –¥–ª—è TTS API (30 —Å–µ–∫—É–Ω–¥)
            response = await asyncio.wait_for(
                asyncio.to_thread(
                    client.audio.speech.create,
                    model=voice_model,
                    voice=voice,
                    input=text,
                    response_format="mp3",
                ),
                timeout=30.0
            )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∞—É–¥–∏–æ—Ñ–∞–π–ª
        logger.info(f"üíæ –°–æ—Ö—Ä–∞–Ω—è—é –≥–æ–ª–æ—Å–æ–≤–æ–π —Ñ–∞–π–ª: {audio_filename}")
        logger.info(f"üìä –†–∞–∑–º–µ—Ä response.content: {len(response.content)} –±–∞–π—Ç")
        try:
            with open(audio_filename, "wb") as f:
                f.write(response.content)
            logger.info(f"‚úÖ –§–∞–π–ª —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {audio_filename}")
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {e}")
            logger.error(f"‚ùå –¢–∏–ø response.content: {type(response.content)}")
            return None

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Å–æ–∑–¥–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
        file_size = os.path.getsize(audio_filename)
        logger.info(f"‚úÖ –ì–æ–ª–æ—Å–æ–≤–æ–π —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω: {audio_filename} (—Ä–∞–∑–º–µ—Ä: {file_size} –±–∞–π—Ç)")

        if file_size == 0:
            logger.error(f"‚ùå –°–æ–∑–¥–∞–Ω–Ω—ã–π –≥–æ–ª–æ—Å–æ–≤–æ–π —Ñ–∞–π–ª –ø—É—Å—Ç–æ–π: {audio_filename}")
            if os.path.exists(audio_filename):
                os.remove(audio_filename)
            return None

        logger.info(f"üéØ text_to_speech –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ, –≤–æ–∑–≤—Ä–∞—â–∞—é: {audio_filename}")
        return audio_filename

    except asyncio.TimeoutError:
        logger.error("‚è∞ TTS API –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª –∑–∞ 30 —Å–µ–∫—É–Ω–¥ - –ø—Ä–µ–≤—ã—à–µ–Ω timeout")
        return None
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≥–æ–ª–æ—Å–∞: {e}")
        return None


def add_message_to_cache(chat_id, message_data, limit=GROUP_CONTEXT_MESSAGES_LIMIT):
    """–î–æ–±–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∫—ç—à –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞."""
    if chat_id not in GROUP_MESSAGES_CACHE:
        GROUP_MESSAGES_CACHE[chat_id] = []

    GROUP_MESSAGES_CACHE[chat_id].append(message_data)

    # Keep only recent messages
    if len(GROUP_MESSAGES_CACHE[chat_id]) > limit:
        GROUP_MESSAGES_CACHE[chat_id] = GROUP_MESSAGES_CACHE[chat_id][-limit:]


def get_group_chat_context(chat_id):
    """–ü–æ–ª—É—á–∞–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —á–∞—Ç–∞ –∏–∑ –∫—ç—à–∞ —Å–æ–æ–±—â–µ–Ω–∏–π."""
    try:
        if chat_id not in GROUP_MESSAGES_CACHE or not GROUP_MESSAGES_CACHE[chat_id]:
            return "No recent messages found in chat."

        messages = GROUP_MESSAGES_CACHE[chat_id]

        # Format context as text
        context_lines = [f"[{msg['time']}] {msg['user']}: {msg['text']}" for msg in messages]
        context = "Recent chat context:\n" + "\n".join(context_lines)
        return context

    except Exception as e:
        logger.error(f"Error getting group chat context: {e}")
        return "Unable to retrieve chat context."


async def ask_openai(prompt, config, conversation_key, user_info=None):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—Ä–æ—Å –≤ OpenAI –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç–≤–µ—Ç."""
    try:
        with OPENAI_LOCK:
            client = openai.OpenAI(api_key=config["openai_api_key"])

            with CONVERSATIONS_LOCK:
                if conversation_key in CONVERSATIONS:
                    thread_id = CONVERSATIONS[conversation_key]["thread_id"]
                else:
                    thread_resp = client.beta.threads.create()
                    thread_id = thread_resp.id
                    CONVERSATIONS[conversation_key] = {
                        "thread_id": thread_id, 
                        "messages": [],
                        "user_info": user_info or {}
                    }
                
                # –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ, –µ—Å–ª–∏ –æ–Ω–∞ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∞
                if user_info and "user_info" in CONVERSATIONS[conversation_key]:
                    CONVERSATIONS[conversation_key]["user_info"].update(user_info)

            try:
                client.beta.threads.messages.create(
                    thread_id=thread_id, role="user", content=prompt
                )
                run_resp = client.beta.threads.runs.create(
                    thread_id=thread_id, assistant_id=config["assistant_id"]
                )
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è –∏–ª–∏ run: {e}")
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π thread –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
                with CONVERSATIONS_LOCK:
                    if conversation_key in CONVERSATIONS:
                        del CONVERSATIONS[conversation_key]
                return "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –≤ OpenAI"

        start_time = time.time()
        timeout = 45
        while True:
            with OPENAI_LOCK:
                status = client.beta.threads.runs.retrieve(
                    thread_id=thread_id, run_id=run_resp.id
                ).status
            if status == "completed":
                break
            elif status == "failed":
                return "‚ùå –û—à–∏–±–∫–∞: OpenAI Assistant –Ω–µ —Å–º–æ–≥ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∑–∞–ø—Ä–æ—Å."
            elif status == "cancelled":
                return "‚ùå –û—à–∏–±–∫–∞: –ó–∞–ø—Ä–æ—Å –∫ OpenAI Assistant –±—ã–ª –æ—Ç–º–µ–Ω–µ–Ω."
            if time.time() - start_time > timeout:
                return "‚ùå –û—à–∏–±–∫–∞: –ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –æ—Ç OpenAI."
            await asyncio.sleep(2)

        with OPENAI_LOCK:
            messages = client.beta.threads.messages.list(thread_id=thread_id).data

        with CONVERSATIONS_LOCK:
            CONVERSATIONS[conversation_key]["messages"] = []
            for msg in messages:
                if msg.content and len(msg.content) > 0:
                    content_text = ""
                    for content_item in msg.content:
                        if hasattr(content_item, "text") and hasattr(content_item.text, "value"):
                            content_text += content_item.text.value
                        elif hasattr(content_item, "text"):
                            content_text += str(content_item.text)
                    if content_text:
                        CONVERSATIONS[conversation_key]["messages"].append(
                            {"role": msg.role, "content": content_text, "timestamp": msg.created_at}
                        )

        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ç–≤–µ—Ç
        if messages and messages[0].content and len(messages[0].content) > 0:
            first_content = messages[0].content[0]
            if hasattr(first_content, "text") and hasattr(first_content.text, "value"):
                return first_content.text.value
            elif hasattr(first_content, "text"):
                return str(first_content.text)

        return "‚ùå –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç OpenAI"
    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ –≤ ask_openai:")
        return f"‚ùå –û—à–∏–±–∫–∞: {e}"


async def aiogram_bot(config, stop_event):
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞ aiogram —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –≥—Ä—É–ø–ø."""

    # –í–∞–ª–∏–¥–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–∞ –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
    token = config.get("telegram_token")
    if not token:
        logger.error("‚ùå –¢–æ–∫–µ–Ω Telegram –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏")
        return

    is_valid, message = validate_telegram_token(token)
    if not is_valid:
        logger.error(f"‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω Telegram: {message}")
        return

    try:
        bot = Bot(token=token, default=DefaultBotProperties(parse_mode="HTML"))
        dp = Dispatcher()
        bot_user = await bot.get_me()
        bot_username = bot_user.username
        logger.info(f"–ë–æ—Ç {bot_username} –∑–∞–ø—É—â–µ–Ω.")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Telegram API: {e}")
        return

    @dp.message(Command(commands=["start"]))
    async def cmd_start(message: types.Message):
        enable_ai_responses = config.get("enable_ai_responses", True)

        if enable_ai_responses:
            # –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º —Å –ò–ò –æ—Ç–≤–µ—Ç–∞–º–∏
            text = (
                f"üëã –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç {config.get('bot_name', '')}. "
                f"–í –ª–∏—á–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö —è –æ—Ç–≤–µ—á–∞—é –Ω–∞ –≤—Å—ë. "
                f"–í –≥—Ä—É–ø–ø–∞—Ö ‚Äî –∫–æ–≥–¥–∞ –≤—ã —É–ø–æ–º–∏–Ω–∞–µ—Ç–µ –º–µ–Ω—è (@{bot_username}) –∏–ª–∏ –æ—Ç–≤–µ—á–∞–µ—Ç–µ –Ω–∞ –º–æ–∏ —Å–æ–æ–±—â–µ–Ω–∏—è."
            )
        else:
            # –†–µ–∂–∏–º —Ç–æ–ª—å–∫–æ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä–∞
            text = (
                f"üéôÔ∏è –ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç-—Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä {config.get('bot_name', '')}.\n\n"
                f"üìù **–†–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã:** –¢–æ–ª—å–∫–æ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π\n"
                f"üé§ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî —è —Ä–∞—Å–ø–æ–∑–Ω–∞—é —Ä–µ—á—å –∏ –æ—Ç–ø—Ä–∞–≤–ª—é –≤–∞–º —Ç–µ–∫—Å—Ç\n"
                f"üö´ –ò–ò –æ—Ç–≤–µ—Ç—ã –æ—Ç–∫–ª—é—á–µ–Ω—ã ‚Äî —è –Ω–µ –≥–µ–Ω–µ—Ä–∏—Ä—É—é —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –æ—Ç–≤–µ—Ç—ã"
            )

        await message.answer(text)

    @dp.message()
    async def handle_group_message(message: types.Message):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –∏ –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –õ–° –∏ –≥—Ä—É–ø–ø–∞—Ö."""

        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –∏ –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        if not (message.text or message.voice):
            return

        text_content = message.text or message.caption or ""

        # –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –≥—Ä—É–ø–ø –≤ –∫—ç—à –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        if message.chat.type != "private" and (message.text or message.caption):
            user_name = "Unknown"
            if message.from_user:
                user_name = message.from_user.first_name or "User"
                if message.from_user.username:
                    user_name += f" (@{message.from_user.username})"

            # Skip very short messages or system messages
            if len(text_content.strip()) >= 2:
                message_data = {
                    "user": user_name,
                    "text": text_content,
                    "time": message.date.strftime("%H:%M"),
                }
                context_limit = config.get("group_context_limit", GROUP_CONTEXT_MESSAGES_LIMIT)
                add_message_to_cache(message.chat.id, message_data, context_limit)

        # 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –¥–æ–ª–∂–µ–Ω –ª–∏ –±–æ—Ç —Ä–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å
        should_process = False

        if message.chat.type == "private" or message.reply_to_message and message.reply_to_message.from_user.id == bot.id or message.voice or f"@{bot_username}" in text_content:
            should_process = True

        if not should_process:
            return  # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ

        # 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–ª—é—á –¥–∏–∞–ª–æ–≥–∞ (–ª–∏—á–Ω—ã–π –∏–ª–∏ –≥—Ä—É–ø–ø–æ–≤–æ–π)
        if message.chat.type == "private":
            conversation_key = f"{config['telegram_token']}_{message.from_user.id}"
        else:
            conversation_key = f"{config['telegram_token']}_{message.chat.id}"
        
        # 2.1. –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ/–≥—Ä—É–ø–ø–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
        user_info = get_user_info(message)

        # 3. –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∏–∑ —Ç–µ–∫—Å—Ç–∞ –∏–ª–∏ –≥–æ–ª–æ—Å–∞)
        user_prompt = ""
        if message.voice:
            logger.info(
                f"üé§ –ü–æ–ª—É—á–µ–Ω–æ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {message.from_user.first_name if message.from_user else 'Unknown'}"
            )
            try:
                voice_file_id = message.voice.file_id
                logger.info(f"üì• –ù–∞—á–∏–Ω–∞—é —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞ {voice_file_id}")

                file_info = await bot.get_file(voice_file_id)
                ogg_filename = f"{voice_file_id}.ogg"

                logger.info(f"‚¨áÔ∏è –°–∫–∞—á–∏–≤–∞—é —Ñ–∞–π–ª: {file_info.file_path} ‚Üí {ogg_filename}")
                await bot.download_file(file_info.file_path, ogg_filename)

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Å–∫–∞—á–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
                file_size = os.path.getsize(ogg_filename) if os.path.exists(ogg_filename) else 0
                logger.info(f"üìÅ –§–∞–π–ª —Å–∫–∞—á–∞–Ω: {ogg_filename} (—Ä–∞–∑–º–µ—Ä: {file_size} –±–∞–π—Ç)")

                if file_size == 0:
                    logger.error(f"‚ùå –°–∫–∞—á–∞–Ω–Ω—ã–π —Ñ–∞–π–ª –ø—É—Å—Ç–æ–π: {ogg_filename}")
                    await message.reply("‚ùå –û—à–∏–±–∫–∞: –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø—É—Å—Ç–æ–µ")
                    return

                # OpenAI Whisper –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç OGG –Ω–∞–ø—Ä—è–º—É—é - –ù–ï –ù–£–ñ–ù–ê –ö–û–ù–í–ï–†–¢–ê–¶–ò–Ø!
                logger.info("‚úÖ –ü—Ä–æ–ø—É—Å–∫–∞—é –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—é - Whisper –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç OGG –Ω–∞–ø—Ä—è–º—É—é")

                logger.info("ü§ñ –û—Ç–ø—Ä–∞–≤–ª—è—é OGG –Ω–∞–ø—Ä—è–º—É—é –≤ OpenAI Whisper...")
                with OPENAI_LOCK:
                    openai.api_key = config["openai_api_key"]
                    transcribed_text = await transcribe_audio(ogg_filename)

                if transcribed_text:
                    logger.info(f"‚úÖ –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞: '{transcribed_text}'")
                    await message.reply(f'<i>–¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è: "{transcribed_text}"</i>')
                    user_prompt = transcribed_text
                else:
                    logger.error("‚ùå –¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å")
                    await message.reply("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ä–µ—á—å –≤ –≥–æ–ª–æ—Å–æ–≤–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏")
                    return

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
                await message.reply(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
                return
            finally:
                # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π OGG —Ñ–∞–π–ª
                if os.path.exists(ogg_filename):
                    os.remove(ogg_filename)
                    logger.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª: {ogg_filename}")
        else:  # message.text
            user_prompt = message.text
            logger.info(
                f"üí¨ –ü–æ–ª—É—á–µ–Ω–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ: '{user_prompt[:50]}...' –æ—Ç {message.from_user.first_name if message.from_user else 'Unknown'}"
            )

        # 4. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞ (–ò–ò –æ—Ç–≤–µ—Ç—ã –≤–∫–ª—é—á–µ–Ω—ã –∏–ª–∏ —Ç–æ–ª—å–∫–æ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è)
        enable_ai_responses = config.get(
            "enable_ai_responses", True
        )  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤–∫–ª—é—á–µ–Ω—ã –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏

        if not enable_ai_responses:
            # –†–µ–∂–∏–º —Ç–æ–ª—å–∫–æ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ - –ò–ò –æ—Ç–≤–µ—Ç—ã –æ—Ç–∫–ª—é—á–µ–Ω—ã
            if message.voice:
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∏–∞–ª–æ–≥ –≤ —Ä–µ–∂–∏–º–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ
                save_transcription_dialog(conversation_key, "üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ", f'–¢—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏—è: "{user_prompt}"', user_info)
                logger.info("üéØ –ë–æ—Ç –≤ —Ä–µ–∂–∏–º–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä–∞ - –≥–æ–ª–æ—Å –æ–±—Ä–∞–±–æ—Ç–∞–Ω, –¥–∏–∞–ª–æ–≥ —Å–æ—Ö—Ä–∞–Ω–µ–Ω, –ò–ò –æ—Ç–≤–µ—Ç –ø—Ä–æ–ø—É—â–µ–Ω")
                return
            else:
                # For text messages, send info about transcription-only mode
                if message.chat.type == "private":
                    transcriber_reply = "üéôÔ∏è –ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ä–µ–∂–∏–º–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä–∞. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è —Ä–µ—á–∏."
                    await message.reply(transcriber_reply)
                    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∏–∞–ª–æ–≥ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –õ–°
                    save_transcription_dialog(conversation_key, user_prompt, transcriber_reply, user_info)
                # –í –≥—Ä—É–ø–ø–∞—Ö –Ω–µ –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ä–µ–∂–∏–º–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä–∞
                logger.info("üéØ –ë–æ—Ç –≤ —Ä–µ–∂–∏–º–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ç–æ—Ä–∞ - —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ")
                return

        # 5. –û–±—ã—á–Ω—ã–π —Ä–µ–∂–∏–º —Å –ò–ò –æ—Ç–≤–µ—Ç–∞–º–∏
        # –£–±–∏—Ä–∞–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ –±–æ—Ç–∞ –∏–∑ –∑–∞–ø—Ä–æ—Å–∞
        cleaned_prompt = user_prompt.replace(f"@{bot_username}", "").strip()

        if not cleaned_prompt:
            await message.reply("–Ø –≤–∞—Å —Å–ª—É—à–∞—é. –ó–∞–¥–∞–π—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –¥–∞–π—Ç–µ –∫–æ–º–∞–Ω–¥—É.")
            return

        # 6. –§–æ—Ä–º–∏—Ä—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –¥–ª—è –≥—Ä—É–ø–ø
        final_prompt = cleaned_prompt

        # –í –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö –¥–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        if message.chat.type != "private":
            chat_context = get_group_chat_context(message.chat.id)

            # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
            final_prompt = f"""–ö–æ–Ω—Ç–µ–∫—Å—Ç –≥—Ä—É–ø–ø–æ–≤–æ–≥–æ —á–∞—Ç–∞:
{chat_context}

–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –∫ —Ç–µ–±–µ —Å –≤–æ–ø—Ä–æ—Å–æ–º: {cleaned_prompt}

–û—Ç–≤–µ—Ç—å —É—á–∏—Ç—ã–≤–∞—è –∫–æ–Ω—Ç–µ–∫—Å—Ç –±–µ—Å–µ–¥—ã. –ï—Å–ª–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–º–æ–≥–∞–µ—Ç –ø–æ–Ω—è—Ç—å –≤–æ–ø—Ä–æ—Å –ª—É—á—à–µ, –∏—Å–ø–æ–ª—å–∑—É–π –µ–≥–æ. –û—Ç–≤–µ—á–∞–π –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ –∏ –ø–æ –¥–µ–ª—É."""

        # 7. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ OpenAI –∏ –æ—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        logger.info(f"üß† –û—Ç–ø—Ä–∞–≤–ª—è—é –∑–∞–ø—Ä–æ—Å –≤ OpenAI: '{final_prompt[:100]}...'")
        response = await ask_openai(final_prompt, config, conversation_key, user_info)
        logger.info(f"‚úÖ –ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –æ—Ç OpenAI: '{response[:100]}...'")

        # 8. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–π –æ—Ç–≤–µ—Ç
        enable_voice_responses = config.get("enable_voice_responses", False)
        voice_model = config.get("voice_model", "tts-1")
        voice_type = config.get("voice_type", "alloy")

        if enable_voice_responses:
            logger.info("üé§ –ì–µ–Ω–µ—Ä–∏—Ä—É—é –≥–æ–ª–æ—Å–æ–≤–æ–π –æ—Ç–≤–µ—Ç...")
            try:
                # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                logger.info("üîß –í—ã–∑—ã–≤–∞—é text_to_speech...")
                audio_file_path = await text_to_speech(response, config, voice_model, voice_type)
                logger.info(f"üîß text_to_speech –∑–∞–≤–µ—Ä—à–µ–Ω, —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {audio_file_path}")

                if audio_file_path and os.path.exists(audio_file_path):
                    logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç: {response[:50]}...")
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –∏ –≥–æ–ª–æ—Å–æ–≤–æ–π –æ—Ç–≤–µ—Ç
                    await message.reply(response)

                    logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≥–æ–ª–æ—Å–æ–≤–æ–π –æ—Ç–≤–µ—Ç: {audio_file_path}")
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑—É—è FSInputFile
                    voice_file = FSInputFile(audio_file_path)
                    await message.reply_voice(voice_file)

                    logger.info("üéµ –ì–æ–ª–æ—Å–æ–≤–æ–π –æ—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é")

                    # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                    os.remove(audio_file_path)
                    logger.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π –≥–æ–ª–æ—Å–æ–≤–æ–π —Ñ–∞–π–ª: {audio_file_path}")
                else:
                    logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–π —Ñ–∞–π–ª, –æ—Ç–ø—Ä–∞–≤–ª—è—é —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç")
                    await message.reply(response)

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ –æ—Ç–≤–µ—Ç–∞: {e}")
                # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç
                await message.reply(response)
        else:
            # –û–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç
            logger.info(f"üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç: {response[:50]}...")
            await message.reply(response)

        logger.info("üì§ –û—Ç–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é")

    logger.info(f"–ó–∞–ø—É—Å–∫ Telegram-–±–æ—Ç–∞ {config.get('bot_name', '')}...")
    try:
        await bot.delete_webhook(drop_pending_updates=True)
        stop_wait_task = asyncio.create_task(stop_event.wait())
        polling_task = asyncio.create_task(dp.start_polling(bot, handle_signals=False))
        await asyncio.wait([polling_task, stop_wait_task], return_when=asyncio.FIRST_COMPLETED)
        if stop_wait_task.done():
            polling_task.cancel()
            logger.info(f"–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞ {config.get('bot_name', '')} –ø–æ –∑–∞–ø—Ä–æ—Å—É.")
    except Exception:
        logger.exception(f"–û—à–∏–±–∫–∞ –≤ –±–æ—Ç–µ {config.get('bot_name', '')}:")
    finally:
        await bot.session.close()
